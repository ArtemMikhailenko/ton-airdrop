"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useMassTransfer.ts":
/*!**********************************!*\
  !*** ./hooks/useMassTransfer.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMassTransfer: function() { return /* binding */ useMassTransfer; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ton/core */ \"(app-pages-browser)/./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ton_ton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ton/ton */ \"(app-pages-browser)/./node_modules/@ton/ton/dist/index.js\");\n/* harmony import */ var _ton_ton__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ton_ton__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ton_crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ton/crypto */ \"(app-pages-browser)/./node_modules/@ton/crypto/dist/index.js\");\n/* harmony import */ var _wrappers_JettonMinter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/wrappers/JettonMinter */ \"(app-pages-browser)/./wrappers/JettonMinter.ts\");\n/* harmony import */ var _wrappers_JettonWallet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/wrappers/JettonWallet */ \"(app-pages-browser)/./wrappers/JettonWallet.ts\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n\n\n\n\n\n\n\nconst client = new _ton_ton__WEBPACK_IMPORTED_MODULE_2__.TonClient({\n    endpoint: \"https://toncenter.com/api/v2/jsonRPC\"\n});\nfunction useMassTransfer() {\n    const [isSending, setIsSending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        current: 0,\n        total: 0\n    });\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    // üîë –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ—à–µ–ª—å–∫–∞ –∏–∑ –º–Ω–µ–º–æ–Ω–∏–∫–∏\n    const initWallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (mnemonic)=>{\n        try {\n            const words = mnemonic.trim().split(\" \");\n            if (words.length !== 24) {\n                throw new Error(\"Mnemonic must contain exactly 24 words\");\n            }\n            const keyPair = await (0,_ton_crypto__WEBPACK_IMPORTED_MODULE_3__.mnemonicToWalletKey)(words);\n            const wallet = _ton_ton__WEBPACK_IMPORTED_MODULE_2__.WalletContractV4.create({\n                workchain: 0,\n                publicKey: keyPair.publicKey\n            });\n            const address = wallet.address.toString();\n            setWalletAddress(address);\n            console.log(\"\\uD83D\\uDD11 Wallet initialized:\", address);\n            return {\n                wallet,\n                keyPair,\n                address\n            };\n        } catch (error) {\n            console.error(\"‚ùå Wallet init error:\", error);\n            throw new Error(\"Invalid mnemonic phrase\");\n        }\n    }, []);\n    // üöÄ –ù–û–í–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –º–∞—Å—Å–æ–≤–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞ —á–µ—Ä–µ–∑ –º–Ω–µ–º–æ–Ω–∏–∫—É\n    const sendToAllWithMnemonic = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (recipients, jettonMinterAddress, mnemonic)=>{\n        // –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö\n        if (!recipients || recipients.length === 0) {\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"Recipients list is empty\");\n            return;\n        }\n        if (!mnemonic || mnemonic.trim().split(\" \").length !== 24) {\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"Please provide valid 24-word mnemonic\");\n            return;\n        }\n        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–¥—Ä–µ—Å–∞ –∏ —Å—É–º–º—ã\n        for(let i = 0; i < recipients.length; i++){\n            const r = recipients[i];\n            try {\n                _ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(r.address);\n            } catch (e) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"Invalid address at position \".concat(i + 1, \": \").concat(r.address));\n                return;\n            }\n            const amount = parseFloat(r.amount);\n            if (isNaN(amount) || amount <= 0) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"Invalid amount at position \".concat(i + 1, \": \").concat(r.amount));\n                return;\n            }\n        }\n        setIsSending(true);\n        setProgress({\n            current: 0,\n            total: recipients.length\n        });\n        try {\n            console.log(\"\\uD83D\\uDE80 Starting mass transfer to\", recipients.length, \"recipients\");\n            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ—à–µ–ª–µ–∫\n            const { wallet, keyPair, address } = await initWallet(mnemonic);\n            console.log(\"\\uD83D\\uDCBC Sender wallet:\", address);\n            // –ü–æ–ª—É—á–∞–µ–º jetton wallet –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è  \n            const jettonWalletAddress = await getJettonWalletAddress(address, jettonMinterAddress);\n            console.log(\"\\uD83E\\uDE99 Jetton wallet:\", jettonWalletAddress);\n            const jettonWallet = client.open(_wrappers_JettonWallet__WEBPACK_IMPORTED_MODULE_5__.JettonWallet.createFromAddress(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(jettonWalletAddress)));\n            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–∞–∂–¥–æ–º—É –ø–æ–ª—É—á–∞—Ç–µ–ª—é\n            for(let i = 0; i < recipients.length; i++){\n                const recipient = recipients[i];\n                console.log(\"\\uD83D\\uDCE4 Sending \".concat(i + 1, \"/\").concat(recipients.length, \": \").concat(recipient.amount, \" tokens to \").concat(recipient.address));\n                try {\n                    // ‚úÖ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å—É–º–º—É –≤ nanocoins (–¥–æ–±–∞–≤–ª—è–µ–º 9 –Ω—É–ª–µ–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)\n                    const amountInNano = (0,_ton_core__WEBPACK_IMPORTED_MODULE_1__.toNano)(recipient.amount); // \"1.5\" ‚Üí 1500000000n\n                    // –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞ jetton —Ç–æ–∫–µ–Ω–æ–≤\n                    const transferMessage = (0,_ton_ton__WEBPACK_IMPORTED_MODULE_2__.internal)({\n                        to: jettonWalletAddress,\n                        value: (0,_ton_core__WEBPACK_IMPORTED_MODULE_1__.toNano)(\"0.08\"),\n                        body: (0,_ton_core__WEBPACK_IMPORTED_MODULE_1__.beginCell)().storeUint(0x0f8a7ea5, 32) // transfer op\n                        .storeUint(0, 64) // query_id\n                        .storeCoins(amountInNano) // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ nanocoins\n                        .storeAddress(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(recipient.address)) // –ø–æ–ª—É—á–∞—Ç–µ–ª—å\n                        .storeAddress(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(address)) // response_destination\n                        .storeUint(0, 1) // custom_payload null\n                        .storeCoins((0,_ton_core__WEBPACK_IMPORTED_MODULE_1__.toNano)(\"0.02\")) // forward_ton_amount\n                        .storeUint(0, 1) // forward_payload null\n                        .endCell()\n                    });\n                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é\n                    const seqno = await wallet.getSeqno(client.provider(wallet.address));\n                    await wallet.sendTransfer(client.provider(wallet.address), {\n                        seqno,\n                        secretKey: keyPair.secretKey,\n                        messages: [\n                            transferMessage\n                        ]\n                    });\n                    setProgress({\n                        current: i + 1,\n                        total: recipients.length\n                    });\n                    react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].success(\"‚úÖ Sent \".concat(recipient.amount, \" tokens to \").concat(recipient.address.slice(0, 6), \"...\"));\n                    // –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏\n                    if (i < recipients.length - 1) {\n                        console.log(\"‚è≥ Waiting 3 seconds before next transaction...\");\n                        await new Promise((resolve)=>setTimeout(resolve, 3000));\n                    }\n                } catch (error) {\n                    console.error(\"‚ùå Failed to send to \".concat(recipient.address, \":\"), error);\n                    react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"‚ùå Failed: \".concat(recipient.address.slice(0, 6), \"... (\").concat(error, \")\"));\n                    // –û–ø—Ü–∏—è –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–ª–∏ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è\n                    const shouldContinue = confirm(\"Failed to send to \".concat(recipient.address.slice(0, 10), \"...\\n\") + \"Error: \".concat(error, \"\\n\\n\") + \"Continue with remaining recipients?\");\n                    if (!shouldContinue) {\n                        break;\n                    }\n                }\n            }\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].success(\"\\uD83C\\uDF89 Mass transfer completed! Sent to \".concat(progress.current, \" recipients\"));\n            console.log(\"‚úÖ Mass transfer completed successfully\");\n        } catch (error) {\n            console.error(\"‚ùå Mass transfer error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"‚ùå Mass transfer failed: \".concat(error));\n            throw error;\n        } finally{\n            setIsSending(false);\n            setProgress({\n                current: 0,\n                total: 0\n            });\n        }\n    }, [\n        initWallet\n    ]);\n    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è jetton wallet –∞–¥—Ä–µ—Å–∞\n    const getJettonWalletAddress = async (userAddress, jettonMinterAddress)=>{\n        try {\n            const minter = client.open(_wrappers_JettonMinter__WEBPACK_IMPORTED_MODULE_4__.JettonMinter.createFromAddress(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(jettonMinterAddress)));\n            const walletAddress = await minter.getWalletAddressOf(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(userAddress));\n            return walletAddress.toString();\n        } catch (error) {\n            console.error(\"Error getting jetton wallet:\", error);\n            throw new Error(\"Failed to get jetton wallet address\");\n        }\n    };\n    return {\n        sendToAllWithMnemonic,\n        initWallet,\n        isSending,\n        progress,\n        walletAddress\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZU1hc3NUcmFuc2Zlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNlO0FBQ0k7QUFDZjtBQUNLO0FBQ0E7QUFDbkI7QUFPcEMsTUFBTVksU0FBUyxJQUFJUCwrQ0FBU0EsQ0FBQztJQUFFUSxVQUFVO0FBQXVDO0FBR3pFLFNBQVNDO0lBQ1osTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNpQixVQUFVQyxZQUFZLEdBQUdsQiwrQ0FBUUEsQ0FBQztRQUFFbUIsU0FBUztRQUFHQyxPQUFPO0lBQUU7SUFDaEUsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR3RCLCtDQUFRQSxDQUFTO0lBRTNELHFEQUFxRDtJQUNyRCxNQUFNdUIsYUFBYXRCLGtEQUFXQSxDQUFDLE9BQU91QjtRQUNsQyxJQUFJO1lBQ0EsTUFBTUMsUUFBUUQsU0FBU0UsSUFBSSxHQUFHQyxLQUFLLENBQUM7WUFDcEMsSUFBSUYsTUFBTUcsTUFBTSxLQUFLLElBQUk7Z0JBQ3JCLE1BQU0sSUFBSUMsTUFBTTtZQUNwQjtZQUVBLE1BQU1DLFVBQVUsTUFBTXRCLGdFQUFtQkEsQ0FBQ2lCO1lBQzFDLE1BQU1NLFNBQVN6QixzREFBZ0JBLENBQUMwQixNQUFNLENBQUM7Z0JBQ25DQyxXQUFXO2dCQUNYQyxXQUFXSixRQUFRSSxTQUFTO1lBQ2hDO1lBRUEsTUFBTUMsVUFBVUosT0FBT0ksT0FBTyxDQUFDQyxRQUFRO1lBQ3ZDZCxpQkFBaUJhO1lBRWpCRSxRQUFRQyxHQUFHLENBQUMsb0NBQTBCSDtZQUN0QyxPQUFPO2dCQUFFSjtnQkFBUUQ7Z0JBQVNLO1lBQVE7UUFFdEMsRUFBRSxPQUFPSSxPQUFPO1lBQ1pGLFFBQVFFLEtBQUssQ0FBQyx3QkFBd0JBO1lBQ3RDLE1BQU0sSUFBSVYsTUFBTTtRQUNwQjtJQUNKLEdBQUcsRUFBRTtJQUVMLHNEQUFzRDtJQUN0RCxNQUFN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LFVBQWdCLE9BQU5oQyxPQUFNLFVBQ2Y7b0JBRUwsSUFBSSxDQUFDb0MsZ0JBQWdCO3dCQUNqQjtvQkFDSjtnQkFDSjtZQUNKO1lBRUFoRSx1REFBS0EsQ0FBQzJELE9BQU8sQ0FBQyxpREFBd0QsT0FBakJyRCxTQUFTRSxPQUFPLEVBQUM7WUFDdEVrQixRQUFRQyxHQUFHLENBQUM7UUFFaEIsRUFBRSxPQUFPQyxPQUFPO1lBQ1pGLFFBQVFFLEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDNUIsdURBQUtBLENBQUM0QixLQUFLLENBQUMsMkJBQWlDLE9BQU5BO1lBQ3ZDLE1BQU1BO1FBQ1YsU0FBVTtZQUNOdkIsYUFBYTtZQUNiRSxZQUFZO2dCQUFFQyxTQUFTO2dCQUFHQyxPQUFPO1lBQUU7UUFDdkM7SUFDSixHQUFHO1FBQUNHO0tBQVc7SUFFZiw2REFBNkQ7SUFDN0QsTUFBTTJCLHlCQUF5QixPQUFPMkIsYUFBcUJuQztRQUN2RCxJQUFJO1lBQ0EsTUFBTW9DLFNBQVNsRSxPQUFPd0MsSUFBSSxDQUN0QjNDLGdFQUFZQSxDQUFDNEMsaUJBQWlCLENBQUNuRCw4Q0FBT0EsQ0FBQzJDLEtBQUssQ0FBQ0g7WUFHakQsTUFBTXJCLGdCQUFnQixNQUFNeUQsT0FBT0Msa0JBQWtCLENBQUM3RSw4Q0FBT0EsQ0FBQzJDLEtBQUssQ0FBQ2dDO1lBQ3BFLE9BQU94RCxjQUFjZSxRQUFRO1FBQ2pDLEVBQUUsT0FBT0csT0FBTztZQUNaRixRQUFRRSxLQUFLLENBQUMsZ0NBQWdDQTtZQUM5QyxNQUFNLElBQUlWLE1BQU07UUFDcEI7SUFDSjtJQUVBLE9BQU87UUFDSFc7UUFDQWpCO1FBQ0FSO1FBQ0FFO1FBQ0FJO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VNYXNzVHJhbnNmZXIudHM/NzZjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBBZGRyZXNzLCBiZWdpbkNlbGwsIHRvTmFubywgQ2VsbCB9IGZyb20gJ0B0b24vY29yZSc7XG5pbXBvcnQgeyBUb25DbGllbnQsIFdhbGxldENvbnRyYWN0VjQsIGludGVybmFsIH0gZnJvbSAnQHRvbi90b24nO1xuaW1wb3J0IHsgbW5lbW9uaWNUb1dhbGxldEtleSB9IGZyb20gJ0B0b24vY3J5cHRvJztcbmltcG9ydCB7IEpldHRvbk1pbnRlciB9IGZyb20gJ0Avd3JhcHBlcnMvSmV0dG9uTWludGVyJztcbmltcG9ydCB7IEpldHRvbldhbGxldCB9IGZyb20gJ0Avd3JhcHBlcnMvSmV0dG9uV2FsbGV0JztcbmltcG9ydCB0b2FzdCBmcm9tICdyZWFjdC1ob3QtdG9hc3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlY2lwaWVudCB7XG4gICAgYWRkcmVzczogc3RyaW5nO1xuICAgIGFtb3VudDogc3RyaW5nOyAvLyDQotC10L/QtdGA0Ywg0LIg0L7QsdGL0YfQvdC+0Lwg0YTQvtGA0LzQsNGC0LU6IFwiMS41XCIsIFwiMlwiLCBcIjAuNVwiXG59XG5cbmNvbnN0IGNsaWVudCA9IG5ldyBUb25DbGllbnQoeyBlbmRwb2ludDogJ2h0dHBzOi8vdG9uY2VudGVyLmNvbS9hcGkvdjIvanNvblJQQycgfSk7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hc3NUcmFuc2ZlcigpIHtcbiAgICBjb25zdCBbaXNTZW5kaW5nLCBzZXRJc1NlbmRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtwcm9ncmVzcywgc2V0UHJvZ3Jlc3NdID0gdXNlU3RhdGUoeyBjdXJyZW50OiAwLCB0b3RhbDogMCB9KTtcbiAgICBjb25zdCBbd2FsbGV0QWRkcmVzcywgc2V0V2FsbGV0QWRkcmVzc10gPSB1c2VTdGF0ZTxzdHJpbmc+KCcnKTtcblxuICAgIC8vIPCflJEg0KTRg9C90LrRhtC40Y8g0LTQu9GPINC40L3QuNGG0LjQsNC70LjQt9Cw0YbQuNC4INC60L7RiNC10LvRjNC60LAg0LjQtyDQvNC90LXQvNC+0L3QuNC60LhcbiAgICBjb25zdCBpbml0V2FsbGV0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKG1uZW1vbmljOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gbW5lbW9uaWMudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBpZiAod29yZHMubGVuZ3RoICE9PSAyNCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTW5lbW9uaWMgbXVzdCBjb250YWluIGV4YWN0bHkgMjQgd29yZHMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qga2V5UGFpciA9IGF3YWl0IG1uZW1vbmljVG9XYWxsZXRLZXkod29yZHMpO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gV2FsbGV0Q29udHJhY3RWNC5jcmVhdGUoeyBcbiAgICAgICAgICAgICAgICB3b3JrY2hhaW46IDAsIFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleToga2V5UGFpci5wdWJsaWNLZXkgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHdhbGxldC5hZGRyZXNzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBzZXRXYWxsZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UkSBXYWxsZXQgaW5pdGlhbGl6ZWQ6JywgYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4geyB3YWxsZXQsIGtleVBhaXIsIGFkZHJlc3MgfTtcbiAgICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFdhbGxldCBpbml0IGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtbmVtb25pYyBwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIPCfmoAg0J3QntCS0JDQryDRhNGD0L3QutGG0LjRjyDQvNCw0YHRgdC+0LLQvtCz0L4g0L/QtdGA0LXQstC+0LTQsCDRh9C10YDQtdC3INC80L3QtdC80L7QvdC40LrRg1xuICAgIGNvbnN0IHNlbmRUb0FsbFdpdGhNbmVtb25pYyA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICAgICAgcmVjaXBpZW50czogUmVjaXBpZW50W10sXG4gICAgICAgIGpldHRvbk1pbnRlckFkZHJlc3M6IHN0cmluZywgIFxuICAgICAgICBtbmVtb25pYzogc3RyaW5nXG4gICAgKSA9PiB7XG4gICAgICAgIC8vINCS0LDQu9C40LTQsNGG0LjRjyDQstGF0L7QtNC90YvRhSDQtNCw0L3QvdGL0YVcbiAgICAgICAgaWYgKCFyZWNpcGllbnRzIHx8IHJlY2lwaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0b2FzdC5lcnJvcignUmVjaXBpZW50cyBsaXN0IGlzIGVtcHR5Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1uZW1vbmljIHx8IG1uZW1vbmljLnRyaW0oKS5zcGxpdCgnICcpLmxlbmd0aCAhPT0gMjQpIHtcbiAgICAgICAgICAgIHRvYXN0LmVycm9yKCdQbGVhc2UgcHJvdmlkZSB2YWxpZCAyNC13b3JkIG1uZW1vbmljJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQn9GA0L7QstC10YDRj9C10Lwg0LDQtNGA0LXRgdCwINC4INGB0YPQvNC80YtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNpcGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByID0gcmVjaXBpZW50c1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBBZGRyZXNzLnBhcnNlKHIuYWRkcmVzcyk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICB0b2FzdC5lcnJvcihgSW52YWxpZCBhZGRyZXNzIGF0IHBvc2l0aW9uICR7aSArIDF9OiAke3IuYWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlRmxvYXQoci5hbW91bnQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGFtb3VudCkgfHwgYW1vdW50IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0b2FzdC5lcnJvcihgSW52YWxpZCBhbW91bnQgYXQgcG9zaXRpb24gJHtpICsgMX06ICR7ci5hbW91bnR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0SXNTZW5kaW5nKHRydWUpO1xuICAgICAgICBzZXRQcm9ncmVzcyh7IGN1cnJlbnQ6IDAsIHRvdGFsOiByZWNpcGllbnRzLmxlbmd0aCB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CfmoAgU3RhcnRpbmcgbWFzcyB0cmFuc2ZlciB0bycsIHJlY2lwaWVudHMubGVuZ3RoLCAncmVjaXBpZW50cycpO1xuXG4gICAgICAgICAgICAvLyDQmNC90LjRhtC40LDQu9C40LfQuNGA0YPQtdC8INC60L7RiNC10LvQtdC6XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldCwga2V5UGFpciwgYWRkcmVzcyB9ID0gYXdhaXQgaW5pdFdhbGxldChtbmVtb25pYyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+SvCBTZW5kZXIgd2FsbGV0OicsIGFkZHJlc3MpO1xuXG4gICAgICAgICAgICAvLyDQn9C+0LvRg9GH0LDQtdC8IGpldHRvbiB3YWxsZXQg0L7RgtC/0YDQsNCy0LjRgtC10LvRjyAgXG4gICAgICAgICAgICBjb25zdCBqZXR0b25XYWxsZXRBZGRyZXNzID0gYXdhaXQgZ2V0SmV0dG9uV2FsbGV0QWRkcmVzcyhhZGRyZXNzLCBqZXR0b25NaW50ZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn6qZIEpldHRvbiB3YWxsZXQ6JywgamV0dG9uV2FsbGV0QWRkcmVzcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGpldHRvbldhbGxldCA9IGNsaWVudC5vcGVuKFxuICAgICAgICAgICAgICAgIEpldHRvbldhbGxldC5jcmVhdGVGcm9tQWRkcmVzcyhBZGRyZXNzLnBhcnNlKGpldHRvbldhbGxldEFkZHJlc3MpKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8g0J7RgtC/0YDQsNCy0LvRj9C10Lwg0LrQsNC20LTQvtC80YMg0L/QvtC70YPRh9Cw0YLQtdC70Y5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjaXBpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2lwaWVudCA9IHJlY2lwaWVudHNbaV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk6QgU2VuZGluZyAke2kgKyAxfS8ke3JlY2lwaWVudHMubGVuZ3RofTogJHtyZWNpcGllbnQuYW1vdW50fSB0b2tlbnMgdG8gJHtyZWNpcGllbnQuYWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyDinIUg0JrQvtC90LLQtdGA0YLQuNGA0YPQtdC8INGB0YPQvNC80YMg0LIgbmFub2NvaW5zICjQtNC+0LHQsNCy0LvRj9C10LwgOSDQvdGD0LvQtdC5INCw0LLRgtC+0LzQsNGC0LjRh9C10YHQutC4KVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbW91bnRJbk5hbm8gPSB0b05hbm8ocmVjaXBpZW50LmFtb3VudCk7IC8vIFwiMS41XCIg4oaSIDE1MDAwMDAwMDBuXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDQodC+0LfQtNCw0LXQvCDRgdC+0L7QsdGJ0LXQvdC40LUg0L/QtdGA0LXQstC+0LTQsCBqZXR0b24g0YLQvtC60LXQvdC+0LJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJNZXNzYWdlID0gaW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGpldHRvbldhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9OYW5vKCcwLjA4JyksIC8vINCT0LDQtyDQtNC70Y8gamV0dG9uINC/0LXRgNC10LLQvtC00LBcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJlZ2luQ2VsbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0b3JlVWludCgweDBmOGE3ZWE1LCAzMikgLy8gdHJhbnNmZXIgb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3RvcmVVaW50KDAsIDY0KSAvLyBxdWVyeV9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdG9yZUNvaW5zKGFtb3VudEluTmFubykgLy8g0LrQvtC70LjRh9C10YHRgtCy0L4g0YLQvtC60LXQvdC+0LIg0LIgbmFub2NvaW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0b3JlQWRkcmVzcyhBZGRyZXNzLnBhcnNlKHJlY2lwaWVudC5hZGRyZXNzKSkgLy8g0L/QvtC70YPRh9Cw0YLQtdC70YxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3RvcmVBZGRyZXNzKEFkZHJlc3MucGFyc2UoYWRkcmVzcykpIC8vIHJlc3BvbnNlX2Rlc3RpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0b3JlVWludCgwLCAxKSAvLyBjdXN0b21fcGF5bG9hZCBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0b3JlQ29pbnModG9OYW5vKCcwLjAyJykpIC8vIGZvcndhcmRfdG9uX2Ftb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdG9yZVVpbnQoMCwgMSkgLy8gZm9yd2FyZF9wYXlsb2FkIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW5kQ2VsbCgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vINCe0YLQv9GA0LDQstC70Y/QtdC8INGC0YDQsNC90LfQsNC60YbQuNGOXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcW5vID0gYXdhaXQgd2FsbGV0LmdldFNlcW5vKGNsaWVudC5wcm92aWRlcih3YWxsZXQuYWRkcmVzcykpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2ZlcihjbGllbnQucHJvdmlkZXIod2FsbGV0LmFkZHJlc3MpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXFubyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3JldEtleToga2V5UGFpci5zZWNyZXRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW3RyYW5zZmVyTWVzc2FnZV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9ncmVzcyh7IGN1cnJlbnQ6IGkgKyAxLCB0b3RhbDogcmVjaXBpZW50cy5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoYOKchSBTZW50ICR7cmVjaXBpZW50LmFtb3VudH0gdG9rZW5zIHRvICR7cmVjaXBpZW50LmFkZHJlc3Muc2xpY2UoMCwgNil9Li4uYCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDQn9Cw0YPQt9CwINC80LXQttC00YMg0YLRgNCw0L3Qt9Cw0LrRhtC40Y/QvNC4XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgcmVjaXBpZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4o+zIFdhaXRpbmcgMyBzZWNvbmRzIGJlZm9yZSBuZXh0IHRyYW5zYWN0aW9uLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gc2VuZCB0byAke3JlY2lwaWVudC5hZGRyZXNzfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0LmVycm9yKGDinYwgRmFpbGVkOiAke3JlY2lwaWVudC5hZGRyZXNzLnNsaWNlKDAsIDYpfS4uLiAoJHtlcnJvcn0pYCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDQntC/0YbQuNGPINC/0YDQvtC00L7Qu9C20LjRgtGMINC40LvQuCDQvtGB0YLQsNC90L7QstC40YLRjNGB0Y9cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ29udGludWUgPSBjb25maXJtKFxuICAgICAgICAgICAgICAgICAgICAgICAgYEZhaWxlZCB0byBzZW5kIHRvICR7cmVjaXBpZW50LmFkZHJlc3Muc2xpY2UoMCwgMTApfS4uLlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYEVycm9yOiAke2Vycm9yfVxcblxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYENvbnRpbnVlIHdpdGggcmVtYWluaW5nIHJlY2lwaWVudHM/YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9hc3Quc3VjY2Vzcyhg8J+OiSBNYXNzIHRyYW5zZmVyIGNvbXBsZXRlZCEgU2VudCB0byAke3Byb2dyZXNzLmN1cnJlbnR9IHJlY2lwaWVudHNgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgTWFzcyB0cmFuc2ZlciBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBNYXNzIHRyYW5zZmVyIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRvYXN0LmVycm9yKGDinYwgTWFzcyB0cmFuc2ZlciBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU2VuZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRQcm9ncmVzcyh7IGN1cnJlbnQ6IDAsIHRvdGFsOiAwIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2luaXRXYWxsZXRdKTtcblxuICAgIC8vINCS0YHQv9C+0LzQvtCz0LDRgtC10LvRjNC90LDRjyDRhNGD0L3QutGG0LjRjyDQtNC70Y8g0L/QvtC70YPRh9C10L3QuNGPIGpldHRvbiB3YWxsZXQg0LDQtNGA0LXRgdCwXG4gICAgY29uc3QgZ2V0SmV0dG9uV2FsbGV0QWRkcmVzcyA9IGFzeW5jICh1c2VyQWRkcmVzczogc3RyaW5nLCBqZXR0b25NaW50ZXJBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWludGVyID0gY2xpZW50Lm9wZW4oXG4gICAgICAgICAgICAgICAgSmV0dG9uTWludGVyLmNyZWF0ZUZyb21BZGRyZXNzKEFkZHJlc3MucGFyc2UoamV0dG9uTWludGVyQWRkcmVzcykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB3YWxsZXRBZGRyZXNzID0gYXdhaXQgbWludGVyLmdldFdhbGxldEFkZHJlc3NPZihBZGRyZXNzLnBhcnNlKHVzZXJBZGRyZXNzKSk7XG4gICAgICAgICAgICByZXR1cm4gd2FsbGV0QWRkcmVzcy50b1N0cmluZygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBqZXR0b24gd2FsbGV0OicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBqZXR0b24gd2FsbGV0IGFkZHJlc3MnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZW5kVG9BbGxXaXRoTW5lbW9uaWMsXG4gICAgICAgIGluaXRXYWxsZXQsXG4gICAgICAgIGlzU2VuZGluZyxcbiAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgIHdhbGxldEFkZHJlc3NcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJBZGRyZXNzIiwiYmVnaW5DZWxsIiwidG9OYW5vIiwiVG9uQ2xpZW50IiwiV2FsbGV0Q29udHJhY3RWNCIsImludGVybmFsIiwibW5lbW9uaWNUb1dhbGxldEtleSIsIkpldHRvbk1pbnRlciIsIkpldHRvbldhbGxldCIsInRvYXN0IiwiY2xpZW50IiwiZW5kcG9pbnQiLCJ1c2VNYXNzVHJhbnNmZXIiLCJpc1NlbmRpbmciLCJzZXRJc1NlbmRpbmciLCJwcm9ncmVzcyIsInNldFByb2dyZXNzIiwiY3VycmVudCIsInRvdGFsIiwid2FsbGV0QWRkcmVzcyIsInNldFdhbGxldEFkZHJlc3MiLCJpbml0V2FsbGV0IiwibW5lbW9uaWMiLCJ3b3JkcyIsInRyaW0iLCJzcGxpdCIsImxlbmd0aCIsIkVycm9yIiwia2V5UGFpciIsIndhbGxldCIsImNyZWF0ZSIsIndvcmtjaGFpbiIsInB1YmxpY0tleSIsImFkZHJlc3MiLCJ0b1N0cmluZyIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsInNlbmRUb0FsbFdpdGhNbmVtb25pYyIsInJlY2lwaWVudHMiLCJqZXR0b25NaW50ZXJBZGRyZXNzIiwiaSIsInIiLCJwYXJzZSIsImFtb3VudCIsInBhcnNlRmxvYXQiLCJpc05hTiIsImpldHRvbldhbGxldEFkZHJlc3MiLCJnZXRKZXR0b25XYWxsZXRBZGRyZXNzIiwiamV0dG9uV2FsbGV0Iiwib3BlbiIsImNyZWF0ZUZyb21BZGRyZXNzIiwicmVjaXBpZW50IiwiYW1vdW50SW5OYW5vIiwidHJhbnNmZXJNZXNzYWdlIiwidG8iLCJ2YWx1ZSIsImJvZHkiLCJzdG9yZVVpbnQiLCJzdG9yZUNvaW5zIiwic3RvcmVBZGRyZXNzIiwiZW5kQ2VsbCIsInNlcW5vIiwiZ2V0U2Vxbm8iLCJwcm92aWRlciIsInNlbmRUcmFuc2ZlciIsInNlY3JldEtleSIsIm1lc3NhZ2VzIiwic3VjY2VzcyIsInNsaWNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwic2hvdWxkQ29udGludWUiLCJjb25maXJtIiwidXNlckFkZHJlc3MiLCJtaW50ZXIiLCJnZXRXYWxsZXRBZGRyZXNzT2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useMassTransfer.ts\n"));

/***/ })

});