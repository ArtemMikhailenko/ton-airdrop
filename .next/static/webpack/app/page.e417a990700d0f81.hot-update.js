"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useMassTransfer.ts":
/*!**********************************!*\
  !*** ./hooks/useMassTransfer.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMassTransfer: function() { return /* binding */ useMassTransfer; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ton/core */ \"(app-pages-browser)/./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ton_ton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ton/ton */ \"(app-pages-browser)/./node_modules/@ton/ton/dist/index.js\");\n/* harmony import */ var _ton_ton__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ton_ton__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ton_crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ton/crypto */ \"(app-pages-browser)/./node_modules/@ton/crypto/dist/index.js\");\n/* harmony import */ var _wrappers_JettonMinter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/wrappers/JettonMinter */ \"(app-pages-browser)/./wrappers/JettonMinter.ts\");\n/* harmony import */ var _wrappers_JettonWallet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/wrappers/JettonWallet */ \"(app-pages-browser)/./wrappers/JettonWallet.ts\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n\n\n\n\n\n\n\nconst client = new _ton_ton__WEBPACK_IMPORTED_MODULE_2__.TonClient({\n    endpoint: \"https://testnet.toncenter.com/api/v2/jsonRPC\",\n    apiKey: \"your-api-key-here\" // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à API –∫–ª—é—á\n});\nfunction useMassTransfer() {\n    const [isSending, setIsSending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        current: 0,\n        total: 0\n    });\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    // üîë –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ—à–µ–ª—å–∫–∞ –∏–∑ –º–Ω–µ–º–æ–Ω–∏–∫–∏\n    const initWallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (mnemonic)=>{\n        try {\n            const words = mnemonic.trim().split(\" \");\n            if (words.length !== 24) {\n                throw new Error(\"Mnemonic must contain exactly 24 words\");\n            }\n            const keyPair = await (0,_ton_crypto__WEBPACK_IMPORTED_MODULE_3__.mnemonicToWalletKey)(words);\n            const wallet = _ton_ton__WEBPACK_IMPORTED_MODULE_2__.WalletContractV4.create({\n                workchain: 0,\n                publicKey: keyPair.publicKey\n            });\n            const address = wallet.address.toString();\n            setWalletAddress(address);\n            console.log(\"\\uD83D\\uDD11 Wallet initialized:\", address);\n            return {\n                wallet,\n                keyPair,\n                address\n            };\n        } catch (error) {\n            console.error(\"‚ùå Wallet init error:\", error);\n            throw new Error(\"Invalid mnemonic phrase\");\n        }\n    }, []);\n    // üöÄ –ù–û–í–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –º–∞—Å—Å–æ–≤–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞ —á–µ—Ä–µ–∑ –º–Ω–µ–º–æ–Ω–∏–∫—É\n    const sendToAllWithMnemonic = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (recipients, jettonMinterAddress, mnemonic)=>{\n        // –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö\n        if (!recipients || recipients.length === 0) {\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"Recipients list is empty\");\n            return;\n        }\n        if (!mnemonic || mnemonic.trim().split(\" \").length !== 24) {\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"Please provide valid 24-word mnemonic\");\n            return;\n        }\n        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–¥—Ä–µ—Å–∞ –∏ —Å—É–º–º—ã\n        for(let i = 0; i < recipients.length; i++){\n            const r = recipients[i];\n            try {\n                _ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(r.address);\n            } catch (e) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"Invalid address at position \".concat(i + 1, \": \").concat(r.address));\n                return;\n            }\n            const amount = parseFloat(r.amount);\n            if (isNaN(amount) || amount <= 0) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"Invalid amount at position \".concat(i + 1, \": \").concat(r.amount));\n                return;\n            }\n        }\n        setIsSending(true);\n        setProgress({\n            current: 0,\n            total: recipients.length\n        });\n        try {\n            console.log(\"\\uD83D\\uDE80 Starting mass transfer to\", recipients.length, \"recipients\");\n            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ—à–µ–ª–µ–∫\n            const { wallet, keyPair, address } = await initWallet(mnemonic);\n            console.log(\"\\uD83D\\uDCBC Sender wallet:\", address);\n            // –ü–æ–ª—É—á–∞–µ–º jetton wallet –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è  \n            const jettonWalletAddress = await getJettonWalletAddress(address, jettonMinterAddress);\n            console.log(\"\\uD83E\\uDE99 Jetton wallet:\", jettonWalletAddress);\n            const jettonWallet = client.open(_wrappers_JettonWallet__WEBPACK_IMPORTED_MODULE_5__.JettonWallet.createFromAddress(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(jettonWalletAddress)));\n            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–∞–∂–¥–æ–º—É –ø–æ–ª—É—á–∞—Ç–µ–ª—é\n            for(let i = 0; i < recipients.length; i++){\n                const recipient = recipients[i];\n                console.log(\"\\uD83D\\uDCE4 Sending \".concat(i + 1, \"/\").concat(recipients.length, \": \").concat(recipient.amount, \" tokens to \").concat(recipient.address));\n                try {\n                    // ‚úÖ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å—É–º–º—É –≤ nanocoins (–¥–æ–±–∞–≤–ª—è–µ–º 9 –Ω—É–ª–µ–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)\n                    const amountInNano = (0,_ton_core__WEBPACK_IMPORTED_MODULE_1__.toNano)(recipient.amount); // \"1.5\" ‚Üí 1500000000n\n                    // –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞ jetton —Ç–æ–∫–µ–Ω–æ–≤\n                    const transferMessage = (0,_ton_ton__WEBPACK_IMPORTED_MODULE_2__.internal)({\n                        to: jettonWalletAddress,\n                        value: (0,_ton_core__WEBPACK_IMPORTED_MODULE_1__.toNano)(\"0.08\"),\n                        body: (0,_ton_core__WEBPACK_IMPORTED_MODULE_1__.beginCell)().storeUint(0x0f8a7ea5, 32) // transfer op\n                        .storeUint(0, 64) // query_id\n                        .storeCoins(amountInNano) // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ nanocoins\n                        .storeAddress(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(recipient.address)) // –ø–æ–ª—É—á–∞—Ç–µ–ª—å\n                        .storeAddress(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(address)) // response_destination\n                        .storeUint(0, 1) // custom_payload null\n                        .storeCoins((0,_ton_core__WEBPACK_IMPORTED_MODULE_1__.toNano)(\"0.02\")) // forward_ton_amount\n                        .storeUint(0, 1) // forward_payload null\n                        .endCell()\n                    });\n                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é\n                    const seqno = await wallet.getSeqno(client.provider(wallet.address));\n                    await wallet.sendTransfer(client.provider(wallet.address), {\n                        seqno,\n                        secretKey: keyPair.secretKey,\n                        messages: [\n                            transferMessage\n                        ]\n                    });\n                    setProgress({\n                        current: i + 1,\n                        total: recipients.length\n                    });\n                    react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].success(\"‚úÖ Sent \".concat(recipient.amount, \" tokens to \").concat(recipient.address.slice(0, 6), \"...\"));\n                    // –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏\n                    if (i < recipients.length - 1) {\n                        console.log(\"‚è≥ Waiting 3 seconds before next transaction...\");\n                        await new Promise((resolve)=>setTimeout(resolve, 3000));\n                    }\n                } catch (error) {\n                    console.error(\"‚ùå Failed to send to \".concat(recipient.address, \":\"), error);\n                    react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"‚ùå Failed: \".concat(recipient.address.slice(0, 6), \"... (\").concat(error, \")\"));\n                    // –û–ø—Ü–∏—è –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–ª–∏ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è\n                    const shouldContinue = confirm(\"Failed to send to \".concat(recipient.address.slice(0, 10), \"...\\n\") + \"Error: \".concat(error, \"\\n\\n\") + \"Continue with remaining recipients?\");\n                    if (!shouldContinue) {\n                        break;\n                    }\n                }\n            }\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].success(\"\\uD83C\\uDF89 Mass transfer completed! Sent to \".concat(progress.current, \" recipients\"));\n            console.log(\"‚úÖ Mass transfer completed successfully\");\n        } catch (error) {\n            console.error(\"‚ùå Mass transfer error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_6__[\"default\"].error(\"‚ùå Mass transfer failed: \".concat(error));\n            throw error;\n        } finally{\n            setIsSending(false);\n            setProgress({\n                current: 0,\n                total: 0\n            });\n        }\n    }, [\n        initWallet\n    ]);\n    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è jetton wallet –∞–¥—Ä–µ—Å–∞\n    const getJettonWalletAddress = async (userAddress, jettonMinterAddress)=>{\n        try {\n            const minter = client.open(_wrappers_JettonMinter__WEBPACK_IMPORTED_MODULE_4__.JettonMinter.createFromAddress(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(jettonMinterAddress)));\n            const walletAddress = await minter.getWalletAddressOf(_ton_core__WEBPACK_IMPORTED_MODULE_1__.Address.parse(userAddress));\n            return walletAddress.toString();\n        } catch (error) {\n            console.error(\"Error getting jetton wallet:\", error);\n            throw new Error(\"Failed to get jetton wallet address\");\n        }\n    };\n    return {\n        sendToAllWithMnemonic,\n        initWallet,\n        isSending,\n        progress,\n        walletAddress\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZU1hc3NUcmFuc2Zlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNlO0FBQ0k7QUFDZjtBQUNLO0FBQ0E7QUFDbkI7QUFPcEMsTUFBTVksU0FBUyxJQUFJUCwrQ0FBU0EsQ0FBQztJQUN6QlEsVUFBVTtJQUNWQyxRQUFRLG9CQUFvQiwyQkFBMkI7QUFDM0Q7QUFFTyxTQUFTQztJQUNaLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHakIsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDa0IsVUFBVUMsWUFBWSxHQUFHbkIsK0NBQVFBLENBQUM7UUFBRW9CLFNBQVM7UUFBR0MsT0FBTztJQUFFO0lBQ2hFLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUd2QiwrQ0FBUUEsQ0FBUztJQUUzRCxxREFBcUQ7SUFDckQsTUFBTXdCLGFBQWF2QixrREFBV0EsQ0FBQyxPQUFPd0I7UUFDbEMsSUFBSTtZQUNBLE1BQU1DLFFBQVFELFNBQVNFLElBQUksR0FBR0MsS0FBSyxDQUFDO1lBQ3BDLElBQUlGLE1BQU1HLE1BQU0sS0FBSyxJQUFJO2dCQUNyQixNQUFNLElBQUlDLE1BQU07WUFDcEI7WUFFQSxNQUFNQyxVQUFVLE1BQU12QixnRUFBbUJBLENBQUNrQjtZQUMxQyxNQUFNTSxTQUFTMUIsc0RBQWdCQSxDQUFDMkIsTUFBTSxDQUFDO2dCQUNuQ0MsV0FBVztnQkFDWEMsV0FBV0osUUFBUUksU0FBUztZQUNoQztZQUVBLE1BQU1DLFVBQVVKLE9BQU9JLE9BQU8sQ0FBQ0MsUUFBUTtZQUN2Q2QsaUJBQWlCYTtZQUVqQkUsUUFBUUMsR0FBRyxDQUFDLG9DQUEwQkg7WUFDdEMsT0FBTztnQkFBRUo7Z0JBQVFEO2dCQUFTSztZQUFRO1FBRXRDLEVBQUUsT0FBT0ksT0FBTztZQUNaRixRQUFRRSxLQUFLLENBQUMsd0JBQXdCQTtZQUN0QyxNQUFNLElBQUlWLE1BQU07UUFDcEI7SUFDSixHQUFHLEVB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S0FBSyxDQUFDLEdBQUcsS0FBSSxXQUNwRCxVQUFnQixPQUFOaEMsT0FBTSxVQUNmO29CQUVMLElBQUksQ0FBQ29DLGdCQUFnQjt3QkFDakI7b0JBQ0o7Z0JBQ0o7WUFDSjtZQUVBakUsdURBQUtBLENBQUM0RCxPQUFPLENBQUMsaURBQXdELE9BQWpCckQsU0FBU0UsT0FBTyxFQUFDO1lBQ3RFa0IsUUFBUUMsR0FBRyxDQUFDO1FBRWhCLEVBQUUsT0FBT0MsT0FBTztZQUNaRixRQUFRRSxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QzdCLHVEQUFLQSxDQUFDNkIsS0FBSyxDQUFDLDJCQUFpQyxPQUFOQTtZQUN2QyxNQUFNQTtRQUNWLFNBQVU7WUFDTnZCLGFBQWE7WUFDYkUsWUFBWTtnQkFBRUMsU0FBUztnQkFBR0MsT0FBTztZQUFFO1FBQ3ZDO0lBQ0osR0FBRztRQUFDRztLQUFXO0lBRWYsNkRBQTZEO0lBQzdELE1BQU0yQix5QkFBeUIsT0FBTzJCLGFBQXFCbkM7UUFDdkQsSUFBSTtZQUNBLE1BQU1vQyxTQUFTbkUsT0FBT3lDLElBQUksQ0FDdEI1QyxnRUFBWUEsQ0FBQzZDLGlCQUFpQixDQUFDcEQsOENBQU9BLENBQUM0QyxLQUFLLENBQUNIO1lBR2pELE1BQU1yQixnQkFBZ0IsTUFBTXlELE9BQU9DLGtCQUFrQixDQUFDOUUsOENBQU9BLENBQUM0QyxLQUFLLENBQUNnQztZQUNwRSxPQUFPeEQsY0FBY2UsUUFBUTtRQUNqQyxFQUFFLE9BQU9HLE9BQU87WUFDWkYsUUFBUUUsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsTUFBTSxJQUFJVixNQUFNO1FBQ3BCO0lBQ0o7SUFFQSxPQUFPO1FBQ0hXO1FBQ0FqQjtRQUNBUjtRQUNBRTtRQUNBSTtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlTWFzc1RyYW5zZmVyLnRzPzc2YzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQWRkcmVzcywgYmVnaW5DZWxsLCB0b05hbm8sIENlbGwgfSBmcm9tICdAdG9uL2NvcmUnO1xuaW1wb3J0IHsgVG9uQ2xpZW50LCBXYWxsZXRDb250cmFjdFY0LCBpbnRlcm5hbCB9IGZyb20gJ0B0b24vdG9uJztcbmltcG9ydCB7IG1uZW1vbmljVG9XYWxsZXRLZXkgfSBmcm9tICdAdG9uL2NyeXB0byc7XG5pbXBvcnQgeyBKZXR0b25NaW50ZXIgfSBmcm9tICdAL3dyYXBwZXJzL0pldHRvbk1pbnRlcic7XG5pbXBvcnQgeyBKZXR0b25XYWxsZXQgfSBmcm9tICdAL3dyYXBwZXJzL0pldHRvbldhbGxldCc7XG5pbXBvcnQgdG9hc3QgZnJvbSAncmVhY3QtaG90LXRvYXN0JztcblxuZXhwb3J0IGludGVyZmFjZSBSZWNpcGllbnQge1xuICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZzsgLy8g0KLQtdC/0LXRgNGMINCyINC+0LHRi9GH0L3QvtC8INGE0L7RgNC80LDRgtC1OiBcIjEuNVwiLCBcIjJcIiwgXCIwLjVcIlxufVxuXG5jb25zdCBjbGllbnQgPSBuZXcgVG9uQ2xpZW50KHsgXG4gICAgZW5kcG9pbnQ6ICdodHRwczovL3Rlc3RuZXQudG9uY2VudGVyLmNvbS9hcGkvdjIvanNvblJQQycsXG4gICAgYXBpS2V5OiAneW91ci1hcGkta2V5LWhlcmUnIC8vINCX0LDQvNC10L3QuNGC0LUg0L3QsCDQstCw0YggQVBJINC60LvRjtGHXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hc3NUcmFuc2ZlcigpIHtcbiAgICBjb25zdCBbaXNTZW5kaW5nLCBzZXRJc1NlbmRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtwcm9ncmVzcywgc2V0UHJvZ3Jlc3NdID0gdXNlU3RhdGUoeyBjdXJyZW50OiAwLCB0b3RhbDogMCB9KTtcbiAgICBjb25zdCBbd2FsbGV0QWRkcmVzcywgc2V0V2FsbGV0QWRkcmVzc10gPSB1c2VTdGF0ZTxzdHJpbmc+KCcnKTtcblxuICAgIC8vIPCflJEg0KTRg9C90LrRhtC40Y8g0LTQu9GPINC40L3QuNGG0LjQsNC70LjQt9Cw0YbQuNC4INC60L7RiNC10LvRjNC60LAg0LjQtyDQvNC90LXQvNC+0L3QuNC60LhcbiAgICBjb25zdCBpbml0V2FsbGV0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKG1uZW1vbmljOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gbW5lbW9uaWMudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBpZiAod29yZHMubGVuZ3RoICE9PSAyNCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTW5lbW9uaWMgbXVzdCBjb250YWluIGV4YWN0bHkgMjQgd29yZHMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qga2V5UGFpciA9IGF3YWl0IG1uZW1vbmljVG9XYWxsZXRLZXkod29yZHMpO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gV2FsbGV0Q29udHJhY3RWNC5jcmVhdGUoeyBcbiAgICAgICAgICAgICAgICB3b3JrY2hhaW46IDAsIFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleToga2V5UGFpci5wdWJsaWNLZXkgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHdhbGxldC5hZGRyZXNzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBzZXRXYWxsZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UkSBXYWxsZXQgaW5pdGlhbGl6ZWQ6JywgYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4geyB3YWxsZXQsIGtleVBhaXIsIGFkZHJlc3MgfTtcbiAgICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFdhbGxldCBpbml0IGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtbmVtb25pYyBwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIPCfmoAg0J3QntCS0JDQryDRhNGD0L3QutGG0LjRjyDQvNCw0YHRgdC+0LLQvtCz0L4g0L/QtdGA0LXQstC+0LTQsCDRh9C10YDQtdC3INC80L3QtdC80L7QvdC40LrRg1xuICAgIGNvbnN0IHNlbmRUb0FsbFdpdGhNbmVtb25pYyA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICAgICAgcmVjaXBpZW50czogUmVjaXBpZW50W10sXG4gICAgICAgIGpldHRvbk1pbnRlckFkZHJlc3M6IHN0cmluZywgIFxuICAgICAgICBtbmVtb25pYzogc3RyaW5nXG4gICAgKSA9PiB7XG4gICAgICAgIC8vINCS0LDQu9C40LTQsNGG0LjRjyDQstGF0L7QtNC90YvRhSDQtNCw0L3QvdGL0YVcbiAgICAgICAgaWYgKCFyZWNpcGllbnRzIHx8IHJlY2lwaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0b2FzdC5lcnJvcignUmVjaXBpZW50cyBsaXN0IGlzIGVtcHR5Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1uZW1vbmljIHx8IG1uZW1vbmljLnRyaW0oKS5zcGxpdCgnICcpLmxlbmd0aCAhPT0gMjQpIHtcbiAgICAgICAgICAgIHRvYXN0LmVycm9yKCdQbGVhc2UgcHJvdmlkZSB2YWxpZCAyNC13b3JkIG1uZW1vbmljJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQn9GA0L7QstC10YDRj9C10Lwg0LDQtNGA0LXRgdCwINC4INGB0YPQvNC80YtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNpcGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByID0gcmVjaXBpZW50c1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBBZGRyZXNzLnBhcnNlKHIuYWRkcmVzcyk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICB0b2FzdC5lcnJvcihgSW52YWxpZCBhZGRyZXNzIGF0IHBvc2l0aW9uICR7aSArIDF9OiAke3IuYWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlRmxvYXQoci5hbW91bnQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGFtb3VudCkgfHwgYW1vdW50IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0b2FzdC5lcnJvcihgSW52YWxpZCBhbW91bnQgYXQgcG9zaXRpb24gJHtpICsgMX06ICR7ci5hbW91bnR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0SXNTZW5kaW5nKHRydWUpO1xuICAgICAgICBzZXRQcm9ncmVzcyh7IGN1cnJlbnQ6IDAsIHRvdGFsOiByZWNpcGllbnRzLmxlbmd0aCB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CfmoAgU3RhcnRpbmcgbWFzcyB0cmFuc2ZlciB0bycsIHJlY2lwaWVudHMubGVuZ3RoLCAncmVjaXBpZW50cycpO1xuXG4gICAgICAgICAgICAvLyDQmNC90LjRhtC40LDQu9C40LfQuNGA0YPQtdC8INC60L7RiNC10LvQtdC6XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldCwga2V5UGFpciwgYWRkcmVzcyB9ID0gYXdhaXQgaW5pdFdhbGxldChtbmVtb25pYyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+SvCBTZW5kZXIgd2FsbGV0OicsIGFkZHJlc3MpO1xuXG4gICAgICAgICAgICAvLyDQn9C+0LvRg9GH0LDQtdC8IGpldHRvbiB3YWxsZXQg0L7RgtC/0YDQsNCy0LjRgtC10LvRjyAgXG4gICAgICAgICAgICBjb25zdCBqZXR0b25XYWxsZXRBZGRyZXNzID0gYXdhaXQgZ2V0SmV0dG9uV2FsbGV0QWRkcmVzcyhhZGRyZXNzLCBqZXR0b25NaW50ZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn6qZIEpldHRvbiB3YWxsZXQ6JywgamV0dG9uV2FsbGV0QWRkcmVzcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGpldHRvbldhbGxldCA9IGNsaWVudC5vcGVuKFxuICAgICAgICAgICAgICAgIEpldHRvbldhbGxldC5jcmVhdGVGcm9tQWRkcmVzcyhBZGRyZXNzLnBhcnNlKGpldHRvbldhbGxldEFkZHJlc3MpKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8g0J7RgtC/0YDQsNCy0LvRj9C10Lwg0LrQsNC20LTQvtC80YMg0L/QvtC70YPRh9Cw0YLQtdC70Y5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjaXBpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2lwaWVudCA9IHJlY2lwaWVudHNbaV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk6QgU2VuZGluZyAke2kgKyAxfS8ke3JlY2lwaWVudHMubGVuZ3RofTogJHtyZWNpcGllbnQuYW1vdW50fSB0b2tlbnMgdG8gJHtyZWNpcGllbnQuYWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyDinIUg0JrQvtC90LLQtdGA0YLQuNGA0YPQtdC8INGB0YPQvNC80YMg0LIgbmFub2NvaW5zICjQtNC+0LHQsNCy0LvRj9C10LwgOSDQvdGD0LvQtdC5INCw0LLRgtC+0LzQsNGC0LjRh9C10YHQutC4KVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbW91bnRJbk5hbm8gPSB0b05hbm8ocmVjaXBpZW50LmFtb3VudCk7IC8vIFwiMS41XCIg4oaSIDE1MDAwMDAwMDBuXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDQodC+0LfQtNCw0LXQvCDRgdC+0L7QsdGJ0LXQvdC40LUg0L/QtdGA0LXQstC+0LTQsCBqZXR0b24g0YLQvtC60LXQvdC+0LJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJNZXNzYWdlID0gaW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGpldHRvbldhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9OYW5vKCcwLjA4JyksIC8vINCT0LDQtyDQtNC70Y8gamV0dG9uINC/0LXRgNC10LLQvtC00LBcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJlZ2luQ2VsbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0b3JlVWludCgweDBmOGE3ZWE1LCAzMikgLy8gdHJhbnNmZXIgb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3RvcmVVaW50KDAsIDY0KSAvLyBxdWVyeV9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdG9yZUNvaW5zKGFtb3VudEluTmFubykgLy8g0LrQvtC70LjRh9C10YHRgtCy0L4g0YLQvtC60LXQvdC+0LIg0LIgbmFub2NvaW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0b3JlQWRkcmVzcyhBZGRyZXNzLnBhcnNlKHJlY2lwaWVudC5hZGRyZXNzKSkgLy8g0L/QvtC70YPRh9Cw0YLQtdC70YxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3RvcmVBZGRyZXNzKEFkZHJlc3MucGFyc2UoYWRkcmVzcykpIC8vIHJlc3BvbnNlX2Rlc3RpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0b3JlVWludCgwLCAxKSAvLyBjdXN0b21fcGF5bG9hZCBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0b3JlQ29pbnModG9OYW5vKCcwLjAyJykpIC8vIGZvcndhcmRfdG9uX2Ftb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdG9yZVVpbnQoMCwgMSkgLy8gZm9yd2FyZF9wYXlsb2FkIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW5kQ2VsbCgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vINCe0YLQv9GA0LDQstC70Y/QtdC8INGC0YDQsNC90LfQsNC60YbQuNGOXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcW5vID0gYXdhaXQgd2FsbGV0LmdldFNlcW5vKGNsaWVudC5wcm92aWRlcih3YWxsZXQuYWRkcmVzcykpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2ZlcihjbGllbnQucHJvdmlkZXIod2FsbGV0LmFkZHJlc3MpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXFubyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3JldEtleToga2V5UGFpci5zZWNyZXRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW3RyYW5zZmVyTWVzc2FnZV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9ncmVzcyh7IGN1cnJlbnQ6IGkgKyAxLCB0b3RhbDogcmVjaXBpZW50cy5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoYOKchSBTZW50ICR7cmVjaXBpZW50LmFtb3VudH0gdG9rZW5zIHRvICR7cmVjaXBpZW50LmFkZHJlc3Muc2xpY2UoMCwgNil9Li4uYCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDQn9Cw0YPQt9CwINC80LXQttC00YMg0YLRgNCw0L3Qt9Cw0LrRhtC40Y/QvNC4XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgcmVjaXBpZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4o+zIFdhaXRpbmcgMyBzZWNvbmRzIGJlZm9yZSBuZXh0IHRyYW5zYWN0aW9uLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gc2VuZCB0byAke3JlY2lwaWVudC5hZGRyZXNzfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0LmVycm9yKGDinYwgRmFpbGVkOiAke3JlY2lwaWVudC5hZGRyZXNzLnNsaWNlKDAsIDYpfS4uLiAoJHtlcnJvcn0pYCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDQntC/0YbQuNGPINC/0YDQvtC00L7Qu9C20LjRgtGMINC40LvQuCDQvtGB0YLQsNC90L7QstC40YLRjNGB0Y9cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ29udGludWUgPSBjb25maXJtKFxuICAgICAgICAgICAgICAgICAgICAgICAgYEZhaWxlZCB0byBzZW5kIHRvICR7cmVjaXBpZW50LmFkZHJlc3Muc2xpY2UoMCwgMTApfS4uLlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYEVycm9yOiAke2Vycm9yfVxcblxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYENvbnRpbnVlIHdpdGggcmVtYWluaW5nIHJlY2lwaWVudHM/YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9hc3Quc3VjY2Vzcyhg8J+OiSBNYXNzIHRyYW5zZmVyIGNvbXBsZXRlZCEgU2VudCB0byAke3Byb2dyZXNzLmN1cnJlbnR9IHJlY2lwaWVudHNgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgTWFzcyB0cmFuc2ZlciBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBNYXNzIHRyYW5zZmVyIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRvYXN0LmVycm9yKGDinYwgTWFzcyB0cmFuc2ZlciBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU2VuZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRQcm9ncmVzcyh7IGN1cnJlbnQ6IDAsIHRvdGFsOiAwIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2luaXRXYWxsZXRdKTtcblxuICAgIC8vINCS0YHQv9C+0LzQvtCz0LDRgtC10LvRjNC90LDRjyDRhNGD0L3QutGG0LjRjyDQtNC70Y8g0L/QvtC70YPRh9C10L3QuNGPIGpldHRvbiB3YWxsZXQg0LDQtNGA0LXRgdCwXG4gICAgY29uc3QgZ2V0SmV0dG9uV2FsbGV0QWRkcmVzcyA9IGFzeW5jICh1c2VyQWRkcmVzczogc3RyaW5nLCBqZXR0b25NaW50ZXJBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWludGVyID0gY2xpZW50Lm9wZW4oXG4gICAgICAgICAgICAgICAgSmV0dG9uTWludGVyLmNyZWF0ZUZyb21BZGRyZXNzKEFkZHJlc3MucGFyc2UoamV0dG9uTWludGVyQWRkcmVzcykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB3YWxsZXRBZGRyZXNzID0gYXdhaXQgbWludGVyLmdldFdhbGxldEFkZHJlc3NPZihBZGRyZXNzLnBhcnNlKHVzZXJBZGRyZXNzKSk7XG4gICAgICAgICAgICByZXR1cm4gd2FsbGV0QWRkcmVzcy50b1N0cmluZygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBqZXR0b24gd2FsbGV0OicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBqZXR0b24gd2FsbGV0IGFkZHJlc3MnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZW5kVG9BbGxXaXRoTW5lbW9uaWMsXG4gICAgICAgIGluaXRXYWxsZXQsXG4gICAgICAgIGlzU2VuZGluZyxcbiAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgIHdhbGxldEFkZHJlc3NcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJBZGRyZXNzIiwiYmVnaW5DZWxsIiwidG9OYW5vIiwiVG9uQ2xpZW50IiwiV2FsbGV0Q29udHJhY3RWNCIsImludGVybmFsIiwibW5lbW9uaWNUb1dhbGxldEtleSIsIkpldHRvbk1pbnRlciIsIkpldHRvbldhbGxldCIsInRvYXN0IiwiY2xpZW50IiwiZW5kcG9pbnQiLCJhcGlLZXkiLCJ1c2VNYXNzVHJhbnNmZXIiLCJpc1NlbmRpbmciLCJzZXRJc1NlbmRpbmciLCJwcm9ncmVzcyIsInNldFByb2dyZXNzIiwiY3VycmVudCIsInRvdGFsIiwid2FsbGV0QWRkcmVzcyIsInNldFdhbGxldEFkZHJlc3MiLCJpbml0V2FsbGV0IiwibW5lbW9uaWMiLCJ3b3JkcyIsInRyaW0iLCJzcGxpdCIsImxlbmd0aCIsIkVycm9yIiwia2V5UGFpciIsIndhbGxldCIsImNyZWF0ZSIsIndvcmtjaGFpbiIsInB1YmxpY0tleSIsImFkZHJlc3MiLCJ0b1N0cmluZyIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsInNlbmRUb0FsbFdpdGhNbmVtb25pYyIsInJlY2lwaWVudHMiLCJqZXR0b25NaW50ZXJBZGRyZXNzIiwiaSIsInIiLCJwYXJzZSIsImFtb3VudCIsInBhcnNlRmxvYXQiLCJpc05hTiIsImpldHRvbldhbGxldEFkZHJlc3MiLCJnZXRKZXR0b25XYWxsZXRBZGRyZXNzIiwiamV0dG9uV2FsbGV0Iiwib3BlbiIsImNyZWF0ZUZyb21BZGRyZXNzIiwicmVjaXBpZW50IiwiYW1vdW50SW5OYW5vIiwidHJhbnNmZXJNZXNzYWdlIiwidG8iLCJ2YWx1ZSIsImJvZHkiLCJzdG9yZVVpbnQiLCJzdG9yZUNvaW5zIiwic3RvcmVBZGRyZXNzIiwiZW5kQ2VsbCIsInNlcW5vIiwiZ2V0U2Vxbm8iLCJwcm92aWRlciIsInNlbmRUcmFuc2ZlciIsInNlY3JldEtleSIsIm1lc3NhZ2VzIiwic3VjY2VzcyIsInNsaWNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwic2hvdWxkQ29udGludWUiLCJjb25maXJtIiwidXNlckFkZHJlc3MiLCJtaW50ZXIiLCJnZXRXYWxsZXRBZGRyZXNzT2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useMassTransfer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./wrappers/JettonWallet.ts":
/*!**********************************!*\
  !*** ./wrappers/JettonWallet.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JettonWallet: function() { return /* binding */ JettonWallet; },\n/* harmony export */   jettonWalletConfigToCell: function() { return /* binding */ jettonWalletConfigToCell; }\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"(app-pages-browser)/./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction jettonWalletConfigToCell(config) {\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeCoins(0).storeAddress(config.owner).storeAddress(config.minter).storeRef(config.walletCode).endCell();\n}\nclass JettonWallet {\n    static createFromAddress(address) {\n        return new JettonWallet(address);\n    }\n    static createFromConfig(config, code) {\n        let workchain = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const data = jettonWalletConfigToCell(config);\n        const init = {\n            code,\n            data\n        };\n        return new JettonWallet((0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.contractAddress)(workchain, init), init);\n    }\n    async sendDeploy(provider, via, value) {\n        await provider.internal(via, {\n            value,\n            sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n            body: (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().endCell()\n        });\n    }\n    async sendTransfer(provider, via, value, forwardValue, recipient, amount, forwardPayload) {\n        await provider.internal(via, {\n            sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n            body: (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(0x0f8a7ea5, 32).storeUint(0, 64).storeCoins(amount).storeAddress(recipient).storeAddress(via.address).storeUint(0, 1).storeCoins(forwardValue).storeUint(1, 1).storeRef(forwardPayload).endCell(),\n            value: value + forwardValue\n        });\n    }\n    async getJettonBalance(provider) {\n        let state = await provider.getState();\n        if (state.state.type !== \"active\") {\n            return 0n;\n        }\n        let res = await provider.get(\"get_wallet_data\", []);\n        return res.stack.readBigNumber();\n    }\n    constructor(address, init){\n        this.address = address;\n        this.init = init;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3dyYXBwZXJzL0pldHRvbldhbGxldC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9IO0FBUTdHLFNBQVNHLHlCQUF5QkMsTUFBMEI7SUFDL0QsT0FBT0osb0RBQVNBLEdBQ1hLLFVBQVUsQ0FBQyxHQUNYQyxZQUFZLENBQUNGLE9BQU9HLEtBQUssRUFDekJELFlBQVksQ0FBQ0YsT0FBT0ksTUFBTSxFQUMxQkMsUUFBUSxDQUFDTCxPQUFPTSxVQUFVLEVBQzFCQyxPQUFPO0FBQ2hCO0FBRU8sTUFBTUM7SUFHVCxPQUFPQyxrQkFBa0JDLE9BQWdCLEVBQUU7UUFDdkMsT0FBTyxJQUFJRixhQUFhRTtJQUM1QjtJQUVBLE9BQU9DLGlCQUFpQlgsTUFBMEIsRUFBRVksSUFBVSxFQUFpQjtZQUFmQyxZQUFBQSxpRUFBWTtRQUN4RSxNQUFNQyxPQUFPZix5QkFBeUJDO1FBQ3RDLE1BQU1lLE9BQU87WUFBRUg7WUFBTUU7UUFBSztRQUMxQixPQUFPLElBQUlOLGFBQWFYLDBEQUFlQSxDQUFDZ0IsV0FBV0UsT0FBT0E7SUFDOUQ7SUFFQSxNQUFNQyxXQUFXQyxRQUEwQixFQUFFQyxHQUFXLEVBQUVDLEtBQWEsRUFBRTtRQUNyRSxNQUFNRixTQUFTRyxRQUFRLENBQUNGLEtBQUs7WUFDekJDO1lBQ0FFLFVBQVV2QiwrQ0FBUUEsQ0FBQ3dCLGtCQUFrQjtZQUNyQ0MsTUFBTTNCLG9EQUFTQSxHQUFHVyxPQUFPO1FBQzdCO0lBQ0o7SUFFQSxNQUFNaUIsYUFDRlAsUUFBMEIsRUFDMUJDLEdBQVcsRUFDWEMsS0FBYSxFQUNiTSxZQUFvQixFQUNwQkMsU0FBa0IsRUFDbEJDLE1BQWMsRUFDZEMsY0FBb0IsRUFDdEI7UUFDRSxNQUFNWCxTQUFTRyxRQUFRLENBQUNGLEtBQUs7WUFDekJHLFVBQVV2QiwrQ0FBUUEsQ0FBQ3dCLGtCQUFrQjtZQUNyQ0MsTUFBTTNCLG9EQUFTQSxHQUNWaUMsU0FBUyxDQUFDLFlBQVksSUFDdEJBLFNBQVMsQ0FBQyxHQUFHLElBQ2I1QixVQUFVLENBQUMwQixRQUNYekIsWUFBWSxDQUFDd0IsV0FDYnhCLFlBQVksQ0FBQ2dCLElBQUlSLE9BQU8sRUFDeEJtQixTQUFTLENBQUMsR0FBRyxHQUNiNUIsVUFBVSxDQUFDd0IsY0FDWEksU0FBUyxDQUFDLEdBQUcsR0FDYnhCLFFBQVEsQ0FBQ3VCLGdCQUNUckIsT0FBTztZQUNaWSxPQUFPQSxRQUFRTTtRQUNuQjtJQUNKO0lBRUEsTUFBTUssaUJBQWlCYixRQUEwQixFQUFFO1FBQy9DLElBQUljLFFBQVEsTUFBTWQsU0FBU2UsUUFBUTtRQUNuQyxJQUFJRCxNQUFNQSxLQUFLLENBQUNFLElBQUksS0FBSyxVQUFVO1lBQy9CLE9BQU8sRUFBRTtRQUNiO1FBQ0EsSUFBSUMsTUFBTSxNQUFNakIsU0FBU2tCLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRTtRQUNsRCxPQUFPRCxJQUFJRSxLQUFLLENBQUNDLGFBQWE7SUFDbEM7SUFyREFDLFlBQVksT0FBeUIsRUFBRSxJQUEwQyxDQUFFO2FBQTlENUIsVUFBQUE7YUFBMkJLLE9BQUFBO0lBQW9DO0FBc0R4RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi93cmFwcGVycy9KZXR0b25XYWxsZXQudHM/M2I3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZGRyZXNzLCBiZWdpbkNlbGwsIENlbGwsIENvbnRyYWN0LCBjb250cmFjdEFkZHJlc3MsIENvbnRyYWN0UHJvdmlkZXIsIFNlbmRlciwgU2VuZE1vZGUgfSBmcm9tICdAdG9uL2NvcmUnO1xuXG5leHBvcnQgdHlwZSBKZXR0b25XYWxsZXRDb25maWcgPSB7XG4gICAgb3duZXI6IEFkZHJlc3M7XG4gICAgbWludGVyOiBBZGRyZXNzO1xuICAgIHdhbGxldENvZGU6IENlbGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gamV0dG9uV2FsbGV0Q29uZmlnVG9DZWxsKGNvbmZpZzogSmV0dG9uV2FsbGV0Q29uZmlnKTogQ2VsbCB7XG4gICAgcmV0dXJuIGJlZ2luQ2VsbCgpXG4gICAgICAgIC5zdG9yZUNvaW5zKDApXG4gICAgICAgIC5zdG9yZUFkZHJlc3MoY29uZmlnLm93bmVyKVxuICAgICAgICAuc3RvcmVBZGRyZXNzKGNvbmZpZy5taW50ZXIpXG4gICAgICAgIC5zdG9yZVJlZihjb25maWcud2FsbGV0Q29kZSlcbiAgICAgICAgLmVuZENlbGwoKTtcbn1cblxuZXhwb3J0IGNsYXNzIEpldHRvbldhbGxldCBpbXBsZW1lbnRzIENvbnRyYWN0IHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBhZGRyZXNzOiBBZGRyZXNzLCByZWFkb25seSBpbml0PzogeyBjb2RlOiBDZWxsOyBkYXRhOiBDZWxsIH0pIHt9XG5cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUFkZHJlc3MoYWRkcmVzczogQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gbmV3IEpldHRvbldhbGxldChhZGRyZXNzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUNvbmZpZyhjb25maWc6IEpldHRvbldhbGxldENvbmZpZywgY29kZTogQ2VsbCwgd29ya2NoYWluID0gMCkge1xuICAgICAgICBjb25zdCBkYXRhID0gamV0dG9uV2FsbGV0Q29uZmlnVG9DZWxsKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGluaXQgPSB7IGNvZGUsIGRhdGEgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBKZXR0b25XYWxsZXQoY29udHJhY3RBZGRyZXNzKHdvcmtjaGFpbiwgaW5pdCksIGluaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIHNlbmREZXBsb3kocHJvdmlkZXI6IENvbnRyYWN0UHJvdmlkZXIsIHZpYTogU2VuZGVyLCB2YWx1ZTogYmlnaW50KSB7XG4gICAgICAgIGF3YWl0IHByb3ZpZGVyLmludGVybmFsKHZpYSwge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBzZW5kTW9kZTogU2VuZE1vZGUuUEFZX0dBU19TRVBBUkFURUxZLFxuICAgICAgICAgICAgYm9keTogYmVnaW5DZWxsKCkuZW5kQ2VsbCgpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBzZW5kVHJhbnNmZXIoXG4gICAgICAgIHByb3ZpZGVyOiBDb250cmFjdFByb3ZpZGVyLFxuICAgICAgICB2aWE6IFNlbmRlcixcbiAgICAgICAgdmFsdWU6IGJpZ2ludCxcbiAgICAgICAgZm9yd2FyZFZhbHVlOiBiaWdpbnQsXG4gICAgICAgIHJlY2lwaWVudDogQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBiaWdpbnQsXG4gICAgICAgIGZvcndhcmRQYXlsb2FkOiBDZWxsXG4gICAgKSB7XG4gICAgICAgIGF3YWl0IHByb3ZpZGVyLmludGVybmFsKHZpYSwge1xuICAgICAgICAgICAgc2VuZE1vZGU6IFNlbmRNb2RlLlBBWV9HQVNfU0VQQVJBVEVMWSxcbiAgICAgICAgICAgIGJvZHk6IGJlZ2luQ2VsbCgpXG4gICAgICAgICAgICAgICAgLnN0b3JlVWludCgweDBmOGE3ZWE1LCAzMilcbiAgICAgICAgICAgICAgICAuc3RvcmVVaW50KDAsIDY0KVxuICAgICAgICAgICAgICAgIC5zdG9yZUNvaW5zKGFtb3VudClcbiAgICAgICAgICAgICAgICAuc3RvcmVBZGRyZXNzKHJlY2lwaWVudClcbiAgICAgICAgICAgICAgICAuc3RvcmVBZGRyZXNzKHZpYS5hZGRyZXNzKVxuICAgICAgICAgICAgICAgIC5zdG9yZVVpbnQoMCwgMSlcbiAgICAgICAgICAgICAgICAuc3RvcmVDb2lucyhmb3J3YXJkVmFsdWUpXG4gICAgICAgICAgICAgICAgLnN0b3JlVWludCgxLCAxKVxuICAgICAgICAgICAgICAgIC5zdG9yZVJlZihmb3J3YXJkUGF5bG9hZClcbiAgICAgICAgICAgICAgICAuZW5kQ2VsbCgpLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlICsgZm9yd2FyZFZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRKZXR0b25CYWxhbmNlKHByb3ZpZGVyOiBDb250cmFjdFByb3ZpZGVyKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IGF3YWl0IHByb3ZpZGVyLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChzdGF0ZS5zdGF0ZS50eXBlICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgcmV0dXJuIDBuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBwcm92aWRlci5nZXQoJ2dldF93YWxsZXRfZGF0YScsIFtdKTtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGFjay5yZWFkQmlnTnVtYmVyKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbImJlZ2luQ2VsbCIsImNvbnRyYWN0QWRkcmVzcyIsIlNlbmRNb2RlIiwiamV0dG9uV2FsbGV0Q29uZmlnVG9DZWxsIiwiY29uZmlnIiwic3RvcmVDb2lucyIsInN0b3JlQWRkcmVzcyIsIm93bmVyIiwibWludGVyIiwic3RvcmVSZWYiLCJ3YWxsZXRDb2RlIiwiZW5kQ2VsbCIsIkpldHRvbldhbGxldCIsImNyZWF0ZUZyb21BZGRyZXNzIiwiYWRkcmVzcyIsImNyZWF0ZUZyb21Db25maWciLCJjb2RlIiwid29ya2NoYWluIiwiZGF0YSIsImluaXQiLCJzZW5kRGVwbG95IiwicHJvdmlkZXIiLCJ2aWEiLCJ2YWx1ZSIsImludGVybmFsIiwic2VuZE1vZGUiLCJQQVlfR0FTX1NFUEFSQVRFTFkiLCJib2R5Iiwic2VuZFRyYW5zZmVyIiwiZm9yd2FyZFZhbHVlIiwicmVjaXBpZW50IiwiYW1vdW50IiwiZm9yd2FyZFBheWxvYWQiLCJzdG9yZVVpbnQiLCJnZXRKZXR0b25CYWxhbmNlIiwic3RhdGUiLCJnZXRTdGF0ZSIsInR5cGUiLCJyZXMiLCJnZXQiLCJzdGFjayIsInJlYWRCaWdOdW1iZXIiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./wrappers/JettonWallet.ts\n"));

/***/ })

});